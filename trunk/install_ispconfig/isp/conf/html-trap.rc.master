PATH="/usr/bin:$PATH:/usr/local/bin"
SHELL=/bin/sh
### Copyright (C) 1997-2003 John D. Hardin
### This program is free software; you can redistribute it and/or modify
### it under the terms of the GNU General Public License as published by
### the Free Software Foundation; either version 2 of the License, or
### (at your option) any later version.
###
### This program is distributed in the hope that it will be useful,
### but WITHOUT ANY WARRANTY; without even the implied warranty of
### MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
### GNU General Public License for more details.
###
### Contact the copyright holder for commercial licensing terms
### if you wish to incorporate this code into non-GPL software.
###
#
# <jhardin@impsec.org>
# $Id: html-trap.procmail,v 1.138 2003-01-26 11:25:54-08 jhardin Exp jhardin $
#
# Procmail snippet to defang active-content HTML tags to protect those
# people foolish enough to read their mail from a web browser or
# HTML-enabled mail client. Also mangles the attachment name on executable
# attachments to prevent attacks, at the cost of not being able to run
# programs from within your mail client - which you shouldn't do anyway.
# Also protects against excessively long filenames in attachments, which
# can cause nasty things to happen in some clients, and excessively long
# MIME headers, which may crash or allow exploits of some clients.
#
# All of the configuration options discussed below must be set in the
# procmail script that calls this filter, before this filter is called.
#
# If you wish to override the default list of executable extensions,
# set MANGLE_EXTENSIONS to a regexp (see where it is defined below for
# the proper syntax).
#
# If you wish to block specific executable or document filenames from
# attachments, define $POISONED_EXECUTABLES to point at a filename
# containing one filename per line, with no leading spaces or comments.
# Case is ignored. Wildcards are allowed, using a mishmash of filename
# globbing and regular expression syntax.
#
# Site policy for trapped messages can be specified within limited bounds.
# To redirect poisoned messages to a file, set $SECURITY_QUARANTINE to the
# name of the file. To notify administrator(s), set $SECURITY_NOTIFY and/or
# $SECURITY_NOTIFY_VERBOSE to a comma-delimited address list. The _VERBOSE
# recipients will get the whole message.
#
# If the trapped message cannot be saved in $SECURITY_QUARANTINE for any
# reason, the message will be bounced unless $SECURITY_QUARANTINE_OPTIONAL is
# set to any value.
#
# This performs limited scanning of attachments for M$ macros which contain
# possibly dangerous code (as opposed to specific strings from specific
# variants of specific exploits). To disable this scanning, set
# $DISABLE_MACRO_CHECK to anything. To adjust the score an attachment is
# considered "poisoned" at, set $POISONED_SCORE. The default is 25, which
# should be okay unless you see valid attachments with complex macros. Set
# $SCORE_HISTORY to a filename to track the scores on scanned documents.
# If you wish to do profiling before implementing poisoning, set
# $SCORE_ONLY to anything to scan and possibly record scores but not
# poison. This could also be accomplished by setting $POISONED_SCORE to a
# very high value (200?), which would trap attacks while still allowing
# profiling.
#
# If you wish to send a message to the author of a trapped message, set
# $SECURITY_NOTIFY_SENDER to any value. To replace the canned message that
# is sent to the author of a trapped message, set $SECURITY_NOTIFY_SENDER
# to point at a text file for the message body. No variable expansion is
# performed on the body of this message. If you want to notify the
# sender's postmaster as well, set $SECURITY_NOTIFY_SENDER_POSTMASTER
# to any value. If you are not running this on a mail relay, you can use
# $SECURITY_NOTIFY_RECIPIENT in the same manner as $SECURITY_NOTIFY_SENDER.
#
# This could also be extended fairly easily to allow virus-checking of
# attachments, assuming you have a virus-checker that will run under *nix.
#
# NOTES
#   Requires perl.
#   Attachment scanning requires mktemp and mimencode.
#
#   This is a non-delivering filter recipe unless $SECURITY_QUARANTINE is
#   set.
#
# INVOCATION
#   Insert
#     CONFIG_VARIABLE=some_value
#     INCLUDERC=html-trap.procmail
#   into your .procmailrc at the beginning or end.
#
#   For further details, particularly how to set up site-wide and mail hub
#   or relay filtering, visit:
#   http://www.impsec.org/email-tools/procmail-security.html
#

# possible bug workaround?
LINEBUF=8192

# Size LINEBUF dynamically to deal with excessively large headers
:0 H
* 32000^0
* 1^1 .
{
  LINEBUF="$="
}

# Make sure $LOGFILE exists so the shells don't barf
LOGFILE=${LOGFILE:-"/dev/null"}

#---------------------------------------------------------------------------
# Grab some info for logging
#
NL="
"
SUBJ=""
FROM="unknown"
FROMDOM=""
REPLY_SUPPRESSED=""

:0
* ^Subject[         ]*:[         ]+\/[^ ].+
{
  SUBJ=" in \"$MATCH\""
}

OVERRIDEFORMAIL="Xx:"

# AOL mail servers look up who is dialled in and
# add that user's ID as the X-Apparently-From: header
# This is pretty spoof-proof

:0
* ^Received: from .*\.aol\.com .* by .*\.aol\.com
* ^X-Apparently-From:.*\/[^ ]+@aol\.com
{
  FROM="$MATCH"
  OVERRIDEFORMAIL="To: $FROM"

  SUBJ="$SUBJ from $FROM"
  FROMDOM="aol.com"
}

# otherwise, try Return-Path: (the envelope sender)
# which is still subject to spoofing but may be
# overlooked

:0 E
* ^Return-Path:.*\/<[^>]+@[^>]+>
{
  FROM="$MATCH"

  # Did a mailing list rewrite the Return-Path header?
  :0
  * -1^0
  * 1^0 ^Precedence: (bulk|junk|list)
  * 1^0 ^(List-Id|X-Mailing-List):
  * 9876543210^0 FROM ?? \<owner-
  * 9876543210^0 FROM ?? \<[^@ >]+-l-admin@
  {
    :0
    * ^From:.*\/<[^>]+>
    {
      FROM="$MATCH"
    }
  }

  SUBJ="$SUBJ from $FROM"
  :0
  * ^Return-Path:.*<[^@]+@\/[^>]+
  {
    FROMDOM="$MATCH"
  }
}

# The following runs if Return-Path: header not found
# MAKE SURE your MTA puts in a Return-Path: header!
:0 E
* ^From:.*\/<[^>]+>
{
  FROM="$MATCH"
  SUBJ="$SUBJ from $FROM"
  LOG=" WARN: No usable Return-Path: header found in message.${NL}"

  :0
  *   SECURITY_NOTIFY_SENDER ?? [^ ]
  * ! SECURITY_DISABLE_SMART_REPLY ?? [^ ]
  {
    REPLY_SUPPRESSED="NOTICE: No Return-Path: header. Suppressing sender notification.${NL}"
    LOG=" $REPLY_SUPPRESSED"
    SECURITY_NOTIFY_SENDER=
  }
}

TO=$LOGNAME

:0
* LOGNAME ?? ^root$
{
  # If $LOGNAME is root, we're probably running as a gateway filter:
  # get the "real" to name(s) out of the message headers.
  :0
  * ^To: +\/.*
  {
    TO="$MATCH"
  }
}

# try to get the full recipient address from a Received: header
# this overrides LOGNAME and the To: header
:0
* 1^1 ^Received: .*for \/<?[^> ]+@[^> ]+\.[^> ;]+>?
{
  TO="$MATCH"
}

SUBJ="$SUBJ to $TO"

:0
* ^Message-ID:.*\/<[^>]+>
{
  MSGID="$MATCH"
  SUBJ="$SUBJ msgid=$MSGID"
}

SUBJ="$SUBJ
"

#---------------------------------------------------------------------------
# Override these in /etc/procmailrc as needed
#

STRIPPED_WARNING=${STRIPPED_WARNING:-"
SECURITY NOTICE:

The mail system has removed a file attachment from this message.
The attachment has been discarded.

Please contact your system administrator for details.

"}

POISONED_WARNING=${POISONED_WARNING:-"
SECURITY WARNING!

The mail system has detected that the following
attachment may contain hazardous program code, is
a suspicious file type, or has a suspicious file name.
Do not trust it. Contact your system administrator immediately.

"}

TNEF_WARNING=${TNEF_WARNING:-"
SECURITY NOTICE:

The mail system has removed a Microsoft attachment for security reasons.
The sender should disable sending Rich Text format in Outlook and
disable sending TNEF to the Internet from their Microsoft Exchange gateway.

See http://support.microsoft.com/support/kb/articles/Q241/5/38.ASP
and http://www.microsoft.com/TechNet/exchange/2505ch10.asp
for more information.

"}


# FROM address for notifications
SECURITY_LOCAL_POSTMASTER=${SECURITY_LOCAL_POSTMASTER:-"postmaster"}

# MTA command line options when generating messages
# get recipient(s) from command line
MTA_FLAGS_CMDLN=${MTA_FLAGS_CMDLN:-"-U"}
# get recipient(s) from message headers
MTA_FLAGS_HDRS=${MTA_FLAGS_HDRS:-"-oi -t -f$SECURITY_LOCAL_POSTMASTER"}

# How paranoid to be about stuff embedded in documents
# default: very
SC_MBD=${SECURITY_OFFICE_EMBED_SCORE:-99}


#---------------------------------------------------------------------------
# trap some excessively long RFC-822 headers
#

:0
* ^\/Subject: ..................................................................................................................................................................................................................................................*
{
  LOG=" Trapped excessively long header$SUBJ"
  STATUS="STATUS: Header truncated."
  HDR="$MATCH"

  # truncate the header
  :0 fw h
  * ^\/Subject: .................................................................................................................................................................................................................................................
  | formail -i "$MATCH"

  SECURITY_NOTIFY=${SECURITY_NOTIFY:-"postmaster"}

  :0
  * ! SECURITY_NONOTIFY_LONGSUBJECT ?? [^ ]
  * SECURITY_NOTIFY ?? [^ ]
  * !$ ^X-Loop: EMAIL SECURITY WARNING $HOST $SECRET
  {
    LOG="${NL} NOTIFY $SECURITY_NOTIFY${NL}"

    :0 h ci
    | ( \
        echo "To: $SECURITY_NOTIFY";\
        echo 'From: "Procmail Security daemon"' "<${SECURITY_LOCAL_POSTMASTER}>";\
        echo 'Subject: SECURITY WARNING - possible email attack';\
        echo "X-Loop: EMAIL SECURITY WARNING $HOST $SECRET"; \
        echo ;\
        echo 'Trapped excessively long header:' ;\
        echo "$HDR";\
        echo ;\
        echo "$STATUS";\
        echo ;\
        echo 'Headers from message:';\
        echo ;\
        sed -e 's/^/> /' ;\
      ) | $SENDMAIL $MTA_FLAGS_CMDLN $SECURITY_NOTIFY
  }
}


:0
* 1^1 ^\/(Mime-Version|Date|Resent-Date|Message-ID|Return-Path|From|Status|X-Status|X-Keywords): ......................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................*
{
  LOG=" Trapped excessively long header$SUBJ"
  STATUS="STATUS: Message bounced."
  HDR="$MATCH"

  :0
  * SECURITY_QUARANTINE ?? [^ ]
  {
    STATUS="STATUS: Message quarantined in $SECURITY_QUARANTINE, not delivered to recipient."
  }

  SECURITY_NOTIFY=${SECURITY_NOTIFY:-"postmaster"}

  :0
  * SECURITY_NOTIFY ?? [^ ]
  * !$ ^X-Loop: EMAIL SECURITY WARNING $HOST $SECRET
  {
    LOG="${NL} NOTIFY $SECURITY_NOTIFY${NL}"

    :0 h ci
    | ( \
        echo "To: $SECURITY_NOTIFY";\
        echo 'From: "Procmail Security daemon"' "<${SECURITY_LOCAL_POSTMASTER}>";\
        echo 'Subject: SECURITY WARNING - possible email attack';\
        echo "X-Loop: EMAIL SECURITY WARNING $HOST $SECRET"; \
        echo ;\
        echo 'Trapped excessively long header:' ;\
        echo "$HDR";\
        echo ;\
        echo "$STATUS";\
        echo ;\
        echo 'Headers from message:';\
        echo ;\
        sed -e 's/^/> /' ;\
      ) | $SENDMAIL $MTA_FLAGS_CMDLN $SECURITY_NOTIFY
  }

  :0
  * SECURITY_QUARANTINE ?? [^ ]
  {
    :0
    $SECURITY_QUARANTINE

    :0 e
    {
      # Argh! Quarantine failed!
      # notify administrator
      LOG="${NL} ERR: QUARANTINE FAILED!${NL}"

      # bounce it.
      EXITCODE=65

      :0 h
      * SECURITY_NOTIFY ?? [^ ]
      * !$ ^X-Loop: EMAIL SECURITY WARNING $HOST $SECRET
      | ( \
          echo "To: $SECURITY_NOTIFY";\
          echo 'From: "Procmail Security daemon"' "<${SECURITY_LOCAL_POSTMASTER}>";\
          echo 'Subject: SECURITY WARNING - quarantine failed!';\
          echo "X-Loop: EMAIL SECURITY WARNING $HOST $SECRET"; \
          echo ;\
          echo 'Attempt to quarantine the following message in $SECURITY_QUARANTINE failed.';\
          echo 'Message has been bounced.';\
          echo 'Verify file access permissions:';\
          ls -l $SECURITY_QUARANTINE 2>&1 ;\
          echo ;\
          echo 'Headers from message:';\
          echo ;\
          sed -e 's/^/> /' ;\
        ) | $SENDMAIL $MTA_FLAGS_CMDLN $SECURITY_NOTIFY

    }
  }

  # bounce it.
  EXITCODE=65

  # zap it.
  :0
  /dev/null

}

#---------------------------------------------------------------------------
# Not all MIME can be sanitized...
#
:0
* ^Content-Type[         ]*:.*multipart/((signed)|(encrypted));
* ! SECURITY_DEFANG_SIGNED ?? [^ ]
{
  LOG=" WARN: Cannot sanitize message due to signing or encryption$SUBJ"
}

#---------------------------------------------------------------------------
# Defang HTML active-content tags
#
# NB: In case you think the regexes should be /<[         ]*TAG/, I suggest
# you *try* such tags in your browser first...
#
# Unfortunately the "on*" (e.g. "onload=") syntax is such that we can't
# reliably look for /onload="/ - there may be whitespace around the =.
# This isn't intended to be a full HTML parser, so we'll err on the side of
# safety by defanging everything, even though it may be outside of an HTML
# context.
#
# This keeps getting uglier as more and more holes are discovered.
#
# This will be folded into a better sanitizer Real Soon Now...
#

:0
* 9876543210^1 ! ^Content-Type[         ]*:.*multipart/((signed)|(encrypted));
* 9876543210^1 SECURITY_DEFANG_SIGNED ?? [^ ]
{
#----------- ALL OF THIS IS SKIPPED FOR SIGNED/ENCRYPTED MESSAGES

# "perl -e" has problems when run as root...
DROPPRIVS=YES

:0
* DEBUG_VERBOSE ?? [^ ]
{
  VERBOSE=YES
}

:0 B
* ! SECURITY_TRUST_HTML ?? [^ ]
* 9876543210^1 \<(html|title|body|meta|app|script|object|embed|i?frame|style|img|bgsound|layer|link)
* 9876543210^1 =(3d)?[         ]*["'](&{|([a-z]+script|mocha):)
{

  LOG="Defanging active HTML content$SUBJ"

  HAVE_UUE=

  :0 B
  * ^begin[         ]+([0-9]+)?[         ]+[^         ]+
  {
    HAVE_UUE=YES
    LOG=" UUE content, HTML decode suppression enabled.$NL"
  }

  :0 fw b
  | perl -p -e '        #\
        unless ($ENV{"HAVE_UUE"} && /^M/) {        #\
                if (/ / && /["\047][^"\047\s]*&#x?[1-9][0-9a-f]/i) {        #\
                        while (/["\047][^"\047\s]*&#((4[6-9]|5[0-8]|6[4-9]|[78][0-9]|9[07-9]|1[0-1][0-9]|12[0-2])(?![0-9]))/) {        #\
                                $char = chr($1);        #\
                                s/&#$1;?/$char/g;        #\
                        }        #\
                        while (/["\047][^"\047\s]*&#(x(2[ef]|3[0-9a]|4[0-9a-f]|5[0-9a]|6[1-9a-f]|7[0-9a]))/i) {        #\
                                $char = chr(hex("0$1"));        #\
                                s/&#$1;?/$char/gi;        #\
                        }        #\
                }        #\
                if (/ / && /["\047][^"\047\s]*%[2-7][0-9a-f]/i) {        #\
                        while (/["\047][^"\047\s]*%((2[ef]|3[0-9a]|4[0-9a-f]|5[0-9a]|6[1-9a-f]|7[0-9a]))/i) {        #\
                                $char = chr(hex("0x$1"));        #\
                                s/%$1/$char/gi;        #\
                        }        #\
                }        #\
        }        #\
        if (/<|%3c/) {        #\
                s/(<|%3c)(META|APP|SCRIPT|OBJECT|EMBED|FRAME|IFRAME|LAYER|LINK)/$1DEFANGED_$2/gi;        #\
                unless ($ENV{"SECURITY_TRUST_STYLE_TAGS"}) {        #\
                        s/<STYLE/ <!-- <DEFANGED_STYLE/gi;        #\
                        s/<\/STYLE/ --> <\/DEFANGED_STYLE/gi;        #\
                        s/\sSTYLE\s*=/ DEFANGED_STYLE=/gi;        #\
                }        #\
                if ($ENV{"DEFANG_WEBBUGS"}) {        #\
                        s/<IMG/<DEFANGED_IMG/gi;        #\
                        s/<BGSOUND/<DEFANGED_BGSOUND/gi;        #\
                        if (/<BODY\s/i) {        #\
                                s/\sBACKGROUND\s*=\s*/ DEFANGED_BACKGROUND=/gi;        #\
                        }        #\
                }        #\
                s/\sOn(Abort|Blur|Change|Click|DblClick|DragDrop|Error|Focus|KeyDown|KeyPress|KeyUp|Load|MouseDown|MouseMove|MouseOut|MouseOver|MouseUp|Move|Reset|Resize|Select|Submit|Unload|ContextMenu|DragStart)/ DEFANGED_On$1/gi;        #\
        }        #\
        s/^\s*On(Abort|Blur|Change|Click|DblClick|DragDrop|Error|Focus|KeyDown|KeyPress|KeyUp|Load|MouseDown|MouseMove|MouseOut|MouseOver|MouseUp|Move|Reset|Resize|Select|Submit|Unload|ContextMenu|DragStart)/DEFANGED_On$1/gi;        #\
        s/(["\047\075]|url\()([a-z]+script|mocha):/${1}DEFANGED_$2:/gi;        #\
        s/(["\047\075])&{/${1}DEFANGED_&_{/g unless ($ENV{"HAVE_UUE"} && /^M/);        #\
        '
}

#---------------------------------------------------------------------------
# Mangle HTML and executable attachment filenames enough that they won't
# automatically execute, and limit the length of extremely long attachment
# filenames and MIME headers to prevent buffer overflows and client
# crashes (sigh). Adding ${$} to the mangling inserts a bit of randomness
# so that an active-HTML or BO exploit can't just look for an attachment
# named EXPLOIT.DEFANGED-EXE to get around the defanging.
#
# NOTE: the [         ] has a tab embedded in it - DO NOT remove it...
#

:0
* ! MANGLE_EXTENSIONS ?? [^ ]
{
  MANGLE_EXTENSIONS='html?|exe|com|cmd|bat|pif|sc[rt]|lnk|dll|ocx|do[ct]|xl[swt]|p[po]t|rtf|vb[se]?|hta|p[lm]|sh[bs]|hlp|chm|eml|ws[cfh]|ad[ep]|jse?|md[abew]|ms[ip]|reg|as[dfx]|c[ip]l|pps|wm[avszd]|vcf|nws|wsz|\{[-0-9a-f]+\}'
}


# UUE attachments
:0 B
* ^begin[         ]+([0-9]+)?[         ]+[^         ]+
{
  :0 B
  * ^begin[         ]+([0-9]+)?[         ]+\/[^         ]....................................................................................................+$
  {
    LOG="Truncating extremely long attachment filename $MATCH$SUBJ"

    :0 fw b
    | perl -p -e 'if (/^begin\s+[0-9]*\s/i) {        #\
            ($mode, $filen) = /^begin\s+([0-9]*)\s+(.{64}).*$/i;        #\
            $mode = "644" unless $mode;        #\
            s/^.*$/begin $mode $filen.../ if $filen;        #\
          }'
  }

  :0 B
  * $ ^begin[         ]+([0-9]+)?[         ]+.+\.(${MANGLE_EXTENSIONS})[         ]*$
  {
    LOG="Sanitizing executable UUE attachments$SUBJ"

    :0 fw b
    | perl -p -e '        #\
      if ($stripped) {        #\
        chomp;        #\
        if (/^end$/i || /^\s*$/) {        #\
          $stripped = 0;        #\
        }        #\
        $_ = ""; next;        #\
      }        #\
      if (($junk,$filen) = /^begin\s+([0-9]+\s+)?((\\.|[^"])+\.($ENV{"MANGLE_EXTENSIONS"}|\{[-0-9a-f]+\}))[\.\s]*$/io) {        #\
        if ($specf = $ENV{"STRIPPED_EXECUTABLES"}) {        #\
          if (open(STRIPPED,$specf)) {        #\
            warn " Checking UUE \"$filen\" for stripping.\n";        #\
            while (chomp($stp_spec = <STRIPPED>)) {        #\
              $stp_spec =~ s/^\s+//g;        #\
              $stp_spec =~ s/\s.*$//g;        #\
              next unless $stp_spec;        #\
              $stp_spec =~ s/([^\\])\./$1\\./g;        #\
              $stp_spec =~ s/\*/.*/g;        #\
              $stp_spec =~ s/([^\(])\?/$1./g;        #\
              $stp_spec .= "\$" unless $stp_spec =~ /\$/;        #\
              warn "  Checking against \"$stp_spec\"\n" if $ENV{"DEBUG"};        #\
              if ($filen =~ /^${stp_spec}/i) {        #\
                warn " Stripped UUE attachment \"$filen\".\n";        #\
                $stripped = 1;        #\
                print "\n";        #\
                print "X-Content-Security: [" . $ENV{"HOST"} . "] REPORT: UUE attachment \"$filen\" stripped\n";        #\
                print "\n";        #\
                print $ENV{"STRIPPED_WARNING"};        #\
                print "Filename: $filen\n\n";        #\
                last;        #\
              }        #\
            }        #\
            close(STRIPPED);        #\
            if ($stripped) {        #\
                $_ = <>;        #\
                $_ = ""; next;        #\
            }        #\
          } else {        #\
            warn " ERR: Unable to open stripped-executables file \"$specf\".\n";        #\
          }        #\
        }        #\
        if ($specf = $ENV{"POISONED_EXECUTABLES"}) {        #\
          if (open(POISONED,$specf)) {        #\
            warn " Checking UUE \"$filen\" for poisoning.\n";        #\
            while (chomp($psn_spec = <POISONED>)) {        #\
              $psn_spec =~ s/^\s+//g;        #\
              $psn_spec =~ s/\s.*$//g;        #\
              next unless $psn_spec;        #\
              $psn_spec =~ s/([^\\])\./$1\\./g;        #\
              $psn_spec =~ s/\*/.*/g;        #\
              $psn_spec =~ s/([^\(])\?/$1./g;        #\
              $psn_spec .= "\$" unless $psn_spec =~ /\$/;        #\
              warn "  Checking against \"$psn_spec\"\n" if $ENV{"DEBUG"};        #\
              if ($filen =~ /^${psn_spec}/i) {        #\
                warn " Trapped poisoned attachment \"$filen\".\n";        #\
                print "X-Content-Security: [", $ENV{"HOST"}, "] NOTIFY\n" if $ENV{"SECURITY_NOTIFY"} || $ENV{"SECURITY_NOTIFY_VERBOSE"};        #\
                print "X-Content-Security: [", $ENV{"HOST"}, "] REPORT: Trapped poisoned attachment \"$filen\"\n" if $ENV{"SECURITY_NOTIFY"} || $ENV{"SECURITY_NOTIFY_VERBOSE"};        #\
                print "X-Content-Security: [", $ENV{"HOST"}, "] QUARANTINE\n" if $ENV{"SECURITY_QUARANTINE"};        #\
                print "\n";        #\
                print $ENV{"POISONED_WARNING"};        #\
                print "SUSPICIOUS ATTACHMENT: ";        #\
                last;        #\
              }        #\
            }        #\
            close(POISONED);        #\
          } else {        #\
            warn " ERR: Unable to open poisoned-executables file \"$specf\".\n";        #\
          }        #\
        }        #\
        warn " Mangling executable UUE filename \"$filen\".\n";        #\
        $filen =~ s/\.([-a-z0-9{}]+)$/.${$}DEFANGED-$1/i;        #\
        print "begin 666 $filen\n";        #\
        $_ = "";        #\
      }        #\
    ' 2>> $LOGFILE
  }
}

# MIME attachments and general header sanitizing
:0
* !$ ^X-Content-Security: \[${HOST}\] (QUARANTINE|DISCARD)
* 9876543210^0 ^Content-Type[         ]*:.*(application|multipart)/[^ ]*;
* 9876543210^0 ^Content-Type[         ]*:.*message/rfc822
* 9876543210^0 ^Content-Disposition[         ]*:.*attachment
{
  LOG="Sanitizing MIME attachment headers$SUBJ"

  # Due to procmail not unwrapping MIME attachment headers,
  # (they're in the message body) this perl script has to run against
  # *every* message with MIME attachments to ensure security. Sorry.

  # NOTE: I don't use the CPAN MIME module in order to keep this as simple
  # as possible and to keep it self-contained (i.e. everything is *right here*).
  # (Attachment scanning breaks this. Which is worse - mimencode or Mime::Base64?)

  # If you get "Out of memory" errors in your procmail log, try changing to
  # the following:
  # :0 fw
  # | ulimit -d 15000; perl -p -e '        #\

  POISONED_SCORE=${POISONED_SCORE:-25}

  :0 fw
  | perl -p -e '        #\
      $pastmsghdr = 1 if /^\s*$/;        #\
      $XCS = "X-Content-Security: [" . $ENV{"HOST"} . "]" unless $XCS;        #\
      if ($pastmsghdr) {        #\
        if (!$mimebdry && $mimebdrs[0]) {        #\
          warn " Found no MIME boundary.\n" if $ENV{"DEBUG"};        #\
          $mimebdry = pop @mimebdrs;        #\
          $newbdry = pop @newbdrs;        #\
          $rawbdry = pop @rawbdrs;        #\
          $bdrytoolong = pop @bdrstoolong;        #\
          $gotbdry = pop @gotbdrs;        #\
          $nullbdry = pop @nullbdrs;        #\
        }        #\
        $_ = "" if $strip_attachment && !$gotbdry;        #\
      } else {        #\
        if (($type,$format,$junk) = /^Content-Type\s*:\s.*(application|multipart|message)\/(\S+)(;.*)?$/i) {        #\
          $wanthdr = 1;        #\
          print "X-Security: MIME headers sanitized on ", $ENV{"HOST"}, "\n";        #\
          print "\tSee http://www.impsec.org/email-tools/sanitizer-intro.html\n";        #\
          print "\tfor details. \$Revision: 1.138 $x\$Date: 2003-01-26 11:25:54-08 $x\n";        #\
          print "X-Security: The postmaster has not enabled quarantine of poisoned messages.\n" unless $ENV{"SECURITY_QUARANTINE"};        #\
          if ($type =~ /application/i) {        #\
            $inmimehdr = 1;        #\
          } elsif ($type =~ /message/i && $format =~ /rfc822/i) {        #\
            $rcrsmsg = $inmimehdr = 1;        #\
          }        #\
        } elsif (/^\S/) {        #\
          $wanthdr = 0;        #\
        }        #\
        if ($wanthdr) {        #\
          if (($mimebdry) = /boundary\s*=\s*(("")|("[^"]+")|([^"]\S+))/i) {        #\
            $mimebdry =~ s/(^"|"$)//g;        #\
            $rawbdry = $mimebdry;        #\
            $gotbdry = 1;        #\
            $wanthdr = 0;        #\
            $bdrytoolong = $nullbdry = 0;        #\
            if ($bdrytoolong = (length($mimebdry) > 80)) {        #\
              warn " Truncating long MIME body-part boundary string.\n";        #\
              $newbdry = substr($mimebdry,0,64);        #\
              $mimebdry = quotemeta($mimebdry);        #\
              s/${mimebdry}/${newbdry}/;        #\
              $rawbdry =~ s/${mimebdry}/${newbdry}/;        #\
            } elsif ($nullbdry = (length($mimebdry) < 1)) {        #\
              warn " Replacing null MIME body-part boundary string.\n";        #\
              $newbdry = "==NULL_MIME_BOUNDARY_ATTACK_SANITIZED-${$}==";        #\
              s/boundary\s*=\s*""/boundary = "${newbdry}"/i;        #\
            } else {        #\
              $mimebdry = quotemeta($mimebdry);        #\
            }        #\
          }        #\
        }        #\
      }        #\
      if ($mimebdry || ($gotbdry && $nullbdry) || $inmimehdr) {        #\
        if (/^\s*$/) {        #\
          $inmimehdr = 0;        #\
          if ($rcrsmsg) {        #\
            push @mimebdrs, $mimebdry;        #\
            push @newbdrs, $newbdry;        #\
            push @rawbdrs, $rawbdry;        #\
            push @bdrstoolong, $bdrytoolong;        #\
            push @gotbdrs, $gotbdry;        #\
            push @nullbdrs, $nullbdry;        #\
            $mimebdry = $newbdry = "";        #\
            $rcrsmsg = $pastmsghdr = $bdrytoolong = $gotbdry = 0;        #\
          }        #\
        } elsif (/^--${mimebdry}(--)?$/) {        #\
          $mend = $1;        #\
          s/${mimebdry}/${newbdry}/ if $bdrytoolong;        #\
          s/^--/--${newbdry}${mend}/ if $nullbdry;        #\
          if ($mend) {        #\
            if ($mimebdrs[0]) {        #\
              $mimebdry = pop @mimebdrs;        #\
              $newbdry = pop @newbdrs;        #\
              $rawbdry = pop @rawbdrs;        #\
              $bdrytoolong = pop @bdrstoolong;        #\
              $gotbdry = pop @gotbdrs;        #\
              $nullbdry = pop @nullbdrs;        #\
            }        #\
          } else {        #\
            $inmimehdr = 1;        #\
            $rcrsmsg = $strip_attachment = $check_attachment = 0;        #\
          }        #\
        } elsif (!$inmimehdr && $strip_attachment) {        #\
          $_ = "";        #\
        } elsif (!$inmimehdr && $check_attachment) {        #\
          $check_attachment = 0;        #\
          if ($destf = `mktemp /tmp/mailchk.XXXXXX`) {        #\
            chomp($destf);        #\
            if (open(DECODE,"|mimencode -u -o $destf")) {        #\
              do {        #\
                print $_;        #\
                print DECODE $_;        #\
                $_ = <>;        #\
                $lastline = $_;        #\
              } until (/^\s*$/ || /^--/);        #\
              close(DECODE);        #\
              $msapp = $score = 0;        #\
              @scores = ();        #\
              $why = "";        #\
              # Run virus-checker here.        #\
              open(ATTCH,"< $destf");        #\
              while (<ATTCH>) {        #\
                if (/\023 (INCLUDE(PICTURE|TEXT)[^\000-\037]+)/i) {        #\
                        $why .= "    " . $ENV{"SC_MBD"} . " for $1\n";        #\
                        $score+= $ENV{"SC_MBD"};        #\
                }        #\
                if (/(\000|\001|\004)(VirusProtection)/i) {        #\
                        $why .= "    99 for $&\n";        #\
                        $score+= 99;        #\
                }        #\
                if (/\000(select\s[^\000]*shell\s*\(\s*["\047])/i) {        #\
                        $why .= "    99 for $1\n";        #\
                        $score+= 99;        #\
                }        #\
                if (/\000(regedit)/i) {        #\
                        $why .= "     9 for $1\n";        #\
                        $score+= 9;        #\
                }        #\
                if (/\000(Shell\s*\()/i) {        #\
                        $why .= "     9 for $1\n";        #\
                        $score+= 9;        #\
                }        #\
                if (/\000(Save(Normal|Properties)Prompt)/i) {        #\
                        $why .= "     9 for $1\n";        #\
                        $score+= 9;        #\
                }        #\
                if (/\000(Outlook\.Application)\000/i) {        #\
                        $why .= "     9 for $1\n";        #\
                        $score+= 9;        #\
                }        #\
                if (/\000(CountOfLines)/i) {        #\
                        $why .= "     9 for $1\n";        #\
                        $score+= 9;        #\
                }        #\
                if (/\000(AddFromString)/i) {        #\
                        $why .= "     9 for $1\n";        #\
                        $score+= 9;        #\
                }        #\
                if (/\000(StartupPath)/i) {        #\
                        $why .= "     9 for $1\n";        #\
                        $score+= 9;        #\
                }        #\
                if (/\000(CreateObject)/i) {        #\
                        $why .= "     4 for $1\n";        #\
                        $score+= 4;        #\
                }        #\
                if (/(\000|\004)([a-z0-9_]\.)*(Autoexec|Workbook_(Open|BeforeClose|Window(De)?activate)|Document_(Open|New|Close))/i) {        #\
                        $why .= "     4 for $&\n";        #\
                        $score+= 4;        #\
                }        #\
                if (/(\000|\004)(Logon|AddressLists|AddressEntries|Recipients|Attachments|Logoff)/i) {        #\
                        $why .= "     4 for $&\n";        #\
                        $score+= 4;        #\
                }        #\
                if (/(\000|\004)(Subject|Body)/i) {        #\
                        $why .= "     4 for $&\n" unless $scores[0];        #\
                        $scores[0] = 4;        #\
                }        #\
                if (/\000(Options[^\w\s])/i) {        #\
                        $why .= "     2 for $1\n";        #\
                        $score+= 2;        #\
                }        #\
                if (/\000(CodeModule)/i) {        #\
                        $why .= "     2 for $1\n";        #\
                        $score+= 2;        #\
                }        #\
                if (/\000(([a-z]+\.)?Application)\000/i) {        #\
                        $why .= "     2 for $1\n";        #\
                        $score+= 2;        #\
                }        #\
                if (/(\000|\004)stdole/i) {        #\
                        $why .= "     2 for $&\n";        #\
                        $score+= 2;        #\
                }        #\
                if (/(\000|\004)NormalTemplate/i) {        #\
                        $why .= "     2 for $&\n";        #\
                        $score+= 2;        #\
                }        #\
                if (/\000(ID="{[-0-9A-F]+(}")?)/i) {        #\
                        $why .= "     4 for $1\n";        #\
                        $score+= 4;        #\
                }        #\
                if (/\000(ThisWorkbook)\000/i) {        #\
                        $why .= "     1 for $1\n";        #\
                        $score+= 1;        #\
                }        #\
                if (/\000(PrivateProfileString)/i) {        #\
                        $why .= "     1 for $1\n";        #\
                        $score+= 1;        #\
                }        #\
                if (/(\000|\004)(ActiveDocument|ThisDocument|ThisWorkbook)/i) {        #\
                        $why .= "     1 for $&\n";        #\
                        $score+= 1;        #\
                }        #\
                if (/\000(\[?HKEY_(CLASSES_ROOT|CURRENT_USER|LOCAL_MACHINE))/) {        #\
                        $why .= "     1 for $1\n";        #\
                        $score+= 1;        #\
                }        #\
                $msapp+= 1 if /\000(Microsoft (Word Document|Excel Worksheet|Excel|PowerPoint)|MSWordDoc|Word\.Document\.[0-9]+|Excel\.Sheet\.[0-9]+)\000/;        #\
              }        #\
              close(ATTCH);        #\
              unlink($destf);        #\
              if ($msapp) {        #\
                for (@scores) {        #\
                  $score += $_;        #\
                }        #\
                if ($histfile = $ENV{"SCORE_HISTORY"}) {        #\
                  if (open(HIST,">>$histfile")) {        #\
                    print HIST "score=$score to=".$ENV{"TO"}." from=".$ENV{"FROM"}."\n";        #\
                    close HIST;        #\
                  }        #\
                }        #\
                $poison_score = $ENV{"POISONED_SCORE"};        #\
                $poison_score = 5 if $poison_score < 5;        #\
                if ($score > $poison_score && !$ENV{"SCORE_ONLY"}) {        #\
                  $why =~ s/[\000-\011\013-\037]//g;        #\
                  warn " POSSIBLE MACRO EXPLOIT: Score=$score\n";        #\
                  print "\n\n--$rawbdry\n";        #\
                  print "Content-Type: TEXT/PLAIN;\n";        #\
                  print "$XCS NOTIFY\n" if $ENV{"SECURITY_NOTIFY"} || $ENV{"SECURITY_NOTIFY_VERBOSE"};        #\
                  print "$XCS REPORT: Trapped poisoned Microsoft attachment\n" if $ENV{"SECURITY_NOTIFY"} || $ENV{"SECURITY_NOTIFY_VERBOSE"};        #\
                  if ($ENV{"SCORE_DETAILS"}) {        #\
                          $why2 = $why;        #\
                          $why2 =~ s/^/$XCS REPORT:/gm;        #\
                          print $why2;        #\
                  }        #\
                  print "$XCS QUARANTINE\n" if $ENV{"SECURITY_QUARANTINE"};        #\
                  print "Content-Description: SECURITY WARNING\n\n";        #\
                  print "SECURITY WARNING!\n";        #\
                  print "The mail delivery system has detected that the preceding\n";        #\
                  print "document attachment appears to contain hazardous macro code.\n";        #\
                  print "Macro Scanner score: $score\n";        #\
                  if ($ENV{"SCORE_DETAILS"}) {        #\
                          print "Macro Scanner score details:\n";        #\
                          print $why;        #\
                  }        #\
                  print "Contact your system administrator immediately!\n\n";        #\
                }        #\
              } else {        #\
                $score = 0;        #\
              }        #\
              if ($lastline =~ /^--${mimebdry}(--)?$/) {        #\
                $inmimehdr = 1;        #\
                $check_attachment = 0;        #\
                $lastline =~ s/${mimebdry}/${newbdry}/ if $bdrytoolong;        #\
              }        #\
              print $lastline;        #\
            } else {        #\
              warn " ERR: Decoding: $!  - mimencode?\n";        #\
            }        #\
          } else {        #\
            warn " ERR: Cannot extract - mktemp?\n";        #\
          }        #\
        }        #\
        if ($inmimehdr || $hdrcnt) {        #\
          if (/^(\s+\S|(file)?name)/) {        #\
            s/^\s*/ /;        #\
            s/^\s*// if $hdrtxt =~ /"[^"]*[^;]$/;        #\
            s/\s*\n$//;        #\
            $hdrtxt .= $_;        #\
            $_ = "";        #\
          } else {        #\
            if ($hdrtxt) {        #\
              $hdrtxt =~ s/([^\\])\\"/\1\\ÿ/g;        #\
              if ($hdrtxt =~ /`\s*`/) {        #\
                warn " Fixing double backquotes.\n";        #\
                $hdrtxt =~ s/`\s*`/\\"/g;        #\
              }        #\
              if ($hdrtxt =~ /^[-\w]+\s*:.*name\s*=\s*"[^"]+$/i) {        #\
                warn " Fixing missing close quote on filename.\n";        #\
                $hdrtxt .= "\"";        #\
              }        #\
              while (($hdr, $val) = $hdrtxt =~ /^([-\w]+)\s*:.*\s(\S+)\s*=\s*""/i) {        #\
                warn " Null $val in $hdr header.\n";        #\
                $sval = quotemeta($val);        #\
                $hdrtxt =~ s/\s$sval\s*=\s*""/ X-$val="{null value sanitized}"/;        #\
              }        #\
              unless ($ENV{"SECURITY_DISABLE_OUTLOOK_HACKS"}) {        #\
                while (($hdr,$filen) = $hdrtxt =~ /^(Content-Description)\s*:\s*text\s+from\s+file\s+\047([^\047]+)\047/i) {        #\
                  warn " Fixing file name \"$filen\" in ${hdr}:\n";        #\
                  $newfilen = $filen; $filen = quotemeta($filen);        #\
                  $hdrtxt =~ s/\s+\047${filen}\047/, filename="${newfilen}"/ig;        #\
                }        #\
              }        #\
              while (($junk,$filen,$junk) = $hdrtxt =~ /^Content-[-\w]+\s*:[^"]*("[^"]*"[^"]+)*name\s*=\s*([^"\s]([^;]|;(?!\s))+)/i) {        #\
                warn " Fixing unquoted filename \"$filen\".\n";        #\
                $newfilen = $filen; $filen = quotemeta($filen);        #\
                if ($newfilen =~ /\.[a-z0-9]+"[a-z0-9"]+[\.\s]*$/i) {        #\
                  warn " Defanging quotes-in-extension attack.\n";        #\
                  while ($newfilen =~ /\.[a-z0-9]+"[a-z0-9"]+[\.\s]*$/i) {        #\
                    $newfilen =~ s/\.([a-z0-9]+)"([a-z0-9"]+)[\.\s]*$/.$1$2/i;        #\
                  }        #\
                }        #\
                $newfilen =~ s/\"/\\"/g;        #\
                if ($newfilen =~ /\([^)]*\)/) {        #\
                  warn " Removing embedded RFC822 comments.\n";        #\
                  $newfilen =~ s/\([^)]*\)//g;        #\
                }        #\
                $hdrtxt =~ s/name\s*=\s*${filen}/name="$newfilen"/ig;        #\
              }        #\
              while (($filen) = $hdrtxt =~ /^Content-[-\w]+\s*:.*name\s*=\s*"(=\?[^"]+\?Q\?[^"]+=(2e|3[0-9]|[46][1-9a-f]|[57][0-9a])[^"]+\?=)"/i) {        #\
                warn " Fixing encoded plain characters in \"$filen\".\n";        #\
                $newfilen = $filen; $filen = quotemeta($filen);        #\
                while ($newfilen =~ /=(2e|3[0-9]|[46][1-9a-f]|[57][0-9a])/i) {        #\
                  $char = chr(hex("0x$1"));        #\
                  $newfilen =~ s/=$1/$char/gi;        #\
                }        #\
                $hdrtxt =~ s/name\s*=\s*"${filen}"/name="$newfilen"/ig;        #\
              }        #\
              while (($filen) = $hdrtxt =~ /^Content-[-\w]+\s*:.*name\s*=\s*"([^"]+)[\.\s]+"/i) {        #\
                warn " Fixing trailing spaces/periods in filename.\n";        #\
                $newfilen = $filen; $filen = quotemeta($filen);        #\
                $hdrtxt =~ s/name\s*=\s*"${filen}[\.\s]+"/name="$newfilen"/ig;        #\
              }        #\
              while (($filen) = $hdrtxt =~ /^Content-[-\w]+\s*:.*name\s*=\s*"([^"]{128,})"/i) {        #\
                warn " Shortening long filename.\n";        #\
                $filen =~ s/\s+/ /g;        #\
                substr ($filen,64,32) = "..." while (length($filen) > 120);        #\
                $hdrtxt =~ s/name\s*=\s*"[^"]{120,}"/name="$filen"/i;        #\
                $mangle_mime_type = 1;        #\
              }        #\
              if (($mtype) = $hdrtxt =~ /^Content-Type:\s+([a-z0-9-_]+\/[a-z0-9-_]+)/i) {        #\
                unless ($mtype =~ /^(multipart|text|message)\//i) {        #\
                  unless ($hdrtxt =~ /name\s*=\s*"/i) {        #\
                    $dfrhdr .= "$hdrtxt\n"; $hdrtxt = "";        #\
                  }        #\
                }        #\
              }        #\
              if ($hdrtxt =~ /^Content-Transfer-Encoding\s*:/i) {        #\
                $dfrhdr .= "$hdrtxt\n"; $hdrtxt = "";        #\
              }        #\
              if (($filen) = $hdrtxt =~ /^Content-[-\w]+\s*:.*name\s*=\s*"([^"]+\.(do[ct]|xl[swt]|p[po]t|rtf|pps)(\?=)?)"/i) {        #\
                $stripped = 0;        #\
                if (!$poisoned && ($specf = $ENV{"STRIPPED_EXECUTABLES"})) {        #\
                  if (open(STRIPPED,$specf)) {        #\
                    warn " Checking document \"$filen\" for stripping.\n";        #\
                    while (chomp($stp_spec = <STRIPPED>)) {        #\
                      $stp_spec =~ s/^\s+//g;        #\
                      $stp_spec =~ s/\s.*$//g;        #\
                      next unless $stp_spec;        #\
                      $stp_spec =~ s/([^\\])\./$1\\./g;        #\
                      $stp_spec =~ s/\*/.*/g;        #\
                      $stp_spec =~ s/([^\(])\?/$1./g;        #\
                      $stp_spec .= "(\\?=)?\$" unless $stp_spec =~ /\$/;        #\
                      warn "  Checking against \"$stp_spec\"\n" if $ENV{"DEBUG"};        #\
                      if ($filen =~ /^${stp_spec}/i) {        #\
                        warn " Stripped document \"$filen\".\n";        #\
                        $stripped = 1;        #\
                        print "Content-Type: TEXT/PLAIN;\n";        #\
                        print "$XCS REPORT: Microsoft attachment \"$filen\" stripped\n";        #\
                        print "Content-Description: SECURITY NOTICE\n\n";        #\
                        print $ENV{"STRIPPED_WARNING"};        #\
                        print "Filename: $filen\n\n";        #\
                        print "More headers follow:\n\n" unless $pastmsghdr;        #\
                        $_ = $dfrhdr = $hdrtxt = "";        #\
                        $strip_attachment = 1;        #\
                        $inmimehdr = 0;        #\
                        last;        #\
                      }        #\
                    }        #\
                    close(STRIPPED);        #\
                  } else {        #\
                    warn " ERR: Unable to open stripped-executables file \"$specf\".\n";        #\
                  }        #\
                }        #\
                if (!$poisoned && !$stripped && ($specf = $ENV{"POISONED_EXECUTABLES"})) {        #\
                  if (open(POISONED,$specf)) {        #\
                    warn " Checking document \"$filen\" for poisoning.\n";        #\
                    while (chomp($psn_spec = <POISONED>)) {        #\
                      $psn_spec =~ s/^\s+//g;        #\
                      $psn_spec =~ s/\s.*$//g;        #\
                      next unless $psn_spec;        #\
                      $psn_spec =~ s/([^\\])\./$1\\./g;        #\
                      $psn_spec =~ s/\*/.*/g;        #\
                      $psn_spec =~ s/([^\(])\?/$1./g;        #\
                      $psn_spec .= "(\\?=)?\$" unless $psn_spec =~ /\$/;        #\
                      warn "  Checking against \"$psn_spec\"\n" if $ENV{"DEBUG"};        #\
                      if ($filen =~ /^${psn_spec}/i) {        #\
                        warn " Trapped poisoned document \"$filen\".\n";        #\
                        $poisoned = 1;        #\
                        print "Content-Type: TEXT/PLAIN;\n";        #\
                        print "$XCS NOTIFY\n" if $ENV{"SECURITY_NOTIFY"} || $ENV{"SECURITY_NOTIFY_VERBOSE"};        #\
                        print "$XCS REPORT: Trapped poisoned Microsoft attachment \"$filen\"\n" if $ENV{"SECURITY_NOTIFY"} || $ENV{"SECURITY_NOTIFY_VERBOSE"};        #\
                        print "$XCS QUARANTINE\n" if $ENV{"SECURITY_QUARANTINE"};        #\
                        print "Content-Description: SECURITY WARNING\n\n";        #\
                        print $ENV{"POISONED_WARNING"};        #\
                        print "Macro Scanner score: 0 (poisoned by name, scan skipped)\n\n";        #\
                        last;        #\
                      }        #\
                    }        #\
                    close(POISONED);        #\
                  } else {        #\
                    warn " ERR: Unable to open poisoned-executables file \"$specf\".\n";        #\
                  }        #\
                }        #\
                $check_attachment = 1 unless $ENV{"DISABLE_MACRO_CHECK"};        #\
              }        #\
              if (($bndry) = $hdrtxt =~ /^Content-Type:\s+multipart\/.*\s+boundary\s*=\s*"?([^"]+)"?/i) {        #\
                push @mimebdrs, $mimebdry;        #\
                push @newbdrs, $newbdry;        #\
                push @rawbdrs, $rawbdry;        #\
                push @bdrstoolong, $bdrytoolong;        #\
                push @gotbdrs, $gotbdry;        #\
                push @nullbdrs, $nullbdry;        #\
                $mimebdry = $newbdry = $bndry;        #\
                $mimebdry = quotemeta($mimebdry);        #\
                $rcrsmsg = $bdrytoolong = $gotbdry = 0;        #\
              }        #\
              if ($hdrtxt =~ /^Content-Type:\s+message\/rfc822/i) {        #\
                if (!$inmimehdr) {        #\
                  push @mimebdrs, $mimebdry;        #\
                  push @newbdrs, $newbdry;        #\
                  push @rawbdrs, $rawbdry;        #\
                  push @bdrstoolong, $bdrytoolong;        #\
                  push @gotbdrs, $gotbdry;        #\
                  push @nullbdrs, $nullbdry;        #\
                  $mimebdry = $newbdry = "";        #\
                  $rcrsmsg = $pastmsghdr = $bdrytoolong = $gotbdry = 0;        #\
                } else {        #\
                  $rcrsmsg = 1;        #\
                }        #\
              }        #\
              if ($ENV{"SECURITY_STRIP_MSTNEF"} && $hdrtxt =~ /^Content-Type:\s+application\/MS-TNEF/i) {        #\
                print "Content-Type: TEXT/PLAIN;\n";        #\
                print "$XCS REPORT: Stripped MS-TNEF attachment\n";        #\
                print "Content-Description: SECURITY NOTICE\n\n";        #\
                print $ENV{"TNEF_WARNING"};        #\
                $_ = $dfrhdr = $hdrtxt = "";        #\
                $strip_attachment = 1;        #\
                $inmimehdr = 0;        #\
              }        #\
              while (($filen) = $hdrtxt =~ /^Content-[-\w]+\s*:.*name\s*=\s*"([^"]*\.($ENV{"MANGLE_EXTENSIONS"})(\?=)?)"/io) {        #\
                $stripped = 0;        #\
                if (!$poisoned && ($specf = $ENV{"STRIPPED_EXECUTABLES"})) {        #\
                  if (open(STRIPPED,$specf)) {        #\
                    warn " Checking \"$filen\" for stripping.\n";        #\
                    while (chomp($stp_spec = <STRIPPED>)) {        #\
                      $stp_spec =~ s/^\s+//g;        #\
                      $stp_spec =~ s/\s.*$//g;        #\
                      next unless $stp_spec;        #\
                      $stp_spec =~ s/([^\\])\./$1\\./g;        #\
                      $stp_spec =~ s/\*/.*/g;        #\
                      $stp_spec =~ s/([^\(])\?/$1./g;        #\
                      $stp_spec .= "(\\?=)?\$" unless $stp_spec =~ /\$/;        #\
                      warn "  Checking against \"$stp_spec\"\n" if $ENV{"DEBUG"};        #\
                      if ($filen =~ /^${stp_spec}/i) {        #\
                        warn " Stripped executable \"$filen\".\n";        #\
                        $stripped = 1;        #\
                        print "Content-Type: TEXT/PLAIN;\n";        #\
                        print "$XCS REPORT: Attachment \"$filen\" stripped\n";        #\
                        print "Content-Description: SECURITY NOTICE\n\n";        #\
                        print $ENV{"STRIPPED_WARNING"};        #\
                        print "Filename: $filen\n\n";        #\
                        print "More headers follow:\n\n" unless $pastmsghdr;        #\
                        $_ = $dfrhdr = $hdrtxt = "";        #\
                        $strip_attachment = 1;        #\
                        $inmimehdr = 0;        #\
                        last;        #\
                      }        #\
                    }        #\
                    close(STRIPPED);        #\
                  } else {        #\
                    warn " ERR: Unable to open stripped-executables file \"$specf\".\n";        #\
                  }        #\
                }        #\
                if (!$poisoned && !$stripped && ($specf = $ENV{"POISONED_EXECUTABLES"})) {        #\
                  if (open(POISONED,$specf)) {        #\
                    warn " Checking \"$filen\" for poisoning.\n";        #\
                    while (chomp($psn_spec = <POISONED>)) {        #\
                      $psn_spec =~ s/^\s+//g;        #\
                      $psn_spec =~ s/\s.*$//g;        #\
                      next unless $psn_spec;        #\
                      $psn_spec =~ s/([^\\])\./$1\\./g;        #\
                      $psn_spec =~ s/\*/.*/g;        #\
                      $psn_spec =~ s/([^\(])\?/$1./g;        #\
                      $psn_spec .= "(\\?=)?\$" unless $psn_spec =~ /\$/;        #\
                      warn "  Checking against \"$psn_spec\"\n" if $ENV{"DEBUG"};        #\
                      if ($filen =~ /^${psn_spec}/i) {        #\
                        warn " Trapped poisoned executable \"$filen\".\n";        #\
                        $poisoned = 1;        #\
                        print "Content-Type: TEXT/PLAIN;\n";        #\
                        print "$XCS NOTIFY\n" if $ENV{"SECURITY_NOTIFY"} || $ENV{"SECURITY_NOTIFY_VERBOSE"};        #\
                        print "$XCS REPORT: Trapped poisoned executable \"$filen\"\n" if $ENV{"SECURITY_NOTIFY"} || $ENV{"SECURITY_NOTIFY_VERBOSE"};        #\
                        print "$XCS QUARANTINE\n" if $ENV{"SECURITY_QUARANTINE"};        #\
                        print "Content-Description: SECURITY WARNING\n\n";        #\
                        print $ENV{"POISONED_WARNING"};        #\
                        last;        #\
                      }        #\
                    }        #\
                    close(POISONED);        #\
                  } else {        #\
                    warn " ERR: Unable to open poisoned-executables file \"$specf\".\n";        #\
                  }        #\
                }        #\
                unless ($stripped) {        #\
                  warn " Mangling executable filename \"$filen\".\n";        #\
                  $newfilen = $filen; $filen = quotemeta($filen);        #\
                  $newfilen =~ s/\.([-a-z0-9{}]+(\?=)?)$/.${$}DEFANGED-$1/i;        #\
                  $hdrtxt =~ s/name\s*=\s*"?${filen}"?/name="$newfilen"/ig;        #\
                  $mangle_mime_type = 1;        #\
                }        #\
              }        #\
              if ($mangle_mime_type && $hdrtxt =~ /^Content-Type:\s/i) {        #\
                ($oct) = $hdrtxt =~ /^Content-Type:.*\s(\S+\/\S+;?)/i;        #\
                warn " Mangling MIME type \"$oct\".\n";        #\
                unless ($oct =~ /text\/plain;/i) {        #\
                  print "$XCS original Content-Type was $oct\n";        #\
                  $oct = quotemeta($oct);        #\
                  $hdrtxt =~ s/${oct}/APPLICATION\/DEFANGED;/i;        #\
                }        #\
              }        #\
              if ($mangle_mime_type && $hdrtxt =~ /\sx-mac-\S+/i) {        #\
                $eudora = "";        #\
                while (($eh) = $hdrtxt =~ /(\sx-mac-\S+\s*=\s*\S+;?)/i) {        #\
                  $eudora .= $eh;        #\
                  $eh = quotemeta($eh);        #\
                  $hdrtxt =~ s/${eh}//i;        #\
                }        #\
                print "$XCS removed$eudora\n";        #\
              }        #\
              if (($junk) = $hdrtxt =~ /^Content-Type\s*:\s+(.{128}).{100,}$/i) {        #\
                warn " Truncating long Content-Type header.\n";        #\
                $junk =~ s/"/\\"/g;        #\
                $hdrtxt = "Content-Type: X-BOGUS\/X-BOGUS; originally=\"$junk...\"";        #\
              } elsif (($junk) = $hdrtxt =~ /^Content-Description\s*:\s+(.{128}).{100,}$/i) {        #\
                warn " Truncating long Content-Description header.\n";        #\
                $hdrtxt = "Content-Description: $junk...";        #\
              } elsif (($junk) = $hdrtxt =~ /^Content-[-\w]+\s*:\s+(.{128}).{100,}$/i) {        #\
                warn " Truncating long MIME header.\n";        #\
                $junk =~ s/"/\\"/g;        #\
                $hdrtxt =~ s/^Content-([-\w]+)\s*:.*$/X-Overflow: Content-$1; originally="$junk..."/i;        #\
              }        #\
              $hdrtxt =~ s/\\ÿ/\\"/g;        #\
              print "$hdrtxt\n" if $hdrtxt;        #\
              $hdrtxt = "";        #\
              if (!$inmimehdr) {        #\
                if ($dfrhdr) {        #\
                  if ($mangle_mime_type && $dfrhdr =~ /^Content-Type:\s/i) {        #\
                    ($oct) = $dfrhdr =~ /^Content-Type:[^\n]*\s(\S+\/\S+;?)/i;        #\
                    warn " Mangling MIME type \"$oct\".\n";        #\
                    unless ($oct =~ /text\/plain;/i) {        #\
                      print "$XCS original Content-Type was $oct\n";        #\
                      $oct = quotemeta($oct);        #\
                      $dfrhdr =~ s/${oct}/APPLICATION\/DEFANGED;/i;        #\
                    }        #\
                  }        #\
                  print $dfrhdr; $dfrhdr = "";        #\
                }        #\
                $poisoned = $mangle_mime_type = 0;        #\
              }        #\
            }        #\
            if (/^\S/) {        #\
              s/\s*\n$//;        #\
              $hdrtxt = $_;        #\
              $_ = "";        #\
              $hdrcnt++;        #\
            } else {        #\
              $hdrcnt = 0;        #\
              $hdrtxt = "";        #\
            }        #\
          }        #\
        }        #\
      }        #\
    ' 2>> $LOGFILE
}

}  # ---- END OF SIGNED/ENCRYPTED SKIP

:0 HB
* SECURITY_POISON_WINEXE ?? [^ ]
* !$ ^X-Content-Security: \[${HOST}\] (QUARANTINE|DISCARD)
* ^Content-Transfer-Encoding[        ]*:.*base64
* 9876543210^0 ^Content-Type[         ]*:.*(application|multipart)/[^ ]*;
* 9876543210^0 ^Content-Disposition[         ]*:.*attachment
{
    # not already quarantined
    # check for Windows executable attachments that were not blocked by name
    # rules for postfix from <hobbit@avian.org>, adapted to sanitizer
    # http://archives.neohapsis.com/archives/postfix/2002-04/1841.html
    # NOT 100% reliable, but will catch the simple case of using
    # a benign filename and a bogus MIME type, and letting Windows figure out
    # to execute the attachment directly (vs. opening in a viewer) by its magic

    :0 B D hf
    * 9876543210^0 ^TV[nopqr]....[AB]..A.A....*AAAA...*AAAA
    * 9876543210^0 LnJkYXRhAA
    * 9876543210^0 cmRhdGEAA
    * 9876543210^0 5yZGF0YQAA
    * 9876543210^0 LnJlbG9JAA
    * 9876543210^0 cmVsb2MAA
    * 9876543210^0 5yZWxvYwAA
    | formail -A "X-Content-Security: [$HOST] NOTIFY" \
              -A "X-Content-Security: [$HOST] QUARANTINE" \
              -A "X-Content-Security: [$HOST] REPORT: Trapped Windows executable attachment"
}

:0 HB
* $ ^X-Content-Security: \[${HOST}\] (NOTIFY|QUARANTINE|DISCARD)
{
  :0
  * SECURITY_MSGID_LOG ?? [^ ]
  { JUNK=`echo "$MSGID" >> $SECURITY_MSGID_LOG` }

  :0
  * 9876543210^0 SECURITY_NOTIFY ?? [^ ]
  * 9876543210^0 SECURITY_NOTIFY_VERBOSE ?? [^ ]
  {
    # Notify administration and sender of the attack

    STATUS="STATUS: Message delivered to $TO"
    STATUS_PUBLIC="STATUS: Message delivered."
    REPORT="REPORT: No details available."
    SCORE="REPORT: Not a document, or already poisoned by filename. Not scanned for macros."

    :0
    * SECURITY_QUARANTINE ?? [^ ]
    {
      STATUS="STATUS: Message quarantined in $SECURITY_QUARANTINE, not delivered to recipient."
      STATUS_PUBLIC="STATUS: Message quarantined, not delivered to recipient."
    }

    :0 HB
    * $ ^X-Content-Security: \[${HOST}\] DISCARD
    {
      SECURITY_QUARANTINE=/dev/null
      STATUS="STATUS: Message discarded, not delivered to recipient."
      STATUS_PUBLIC="$STATUS"
    }

    :0 HB
    * ^\/Macro Scanner score: [1-9][0-9]+
    {
      SCORE="REPORT: $MATCH"
    }

    :0 HB
    * $ ^X-Content-Security: \[${HOST}\] REPORT:
    { REPORT=`grep "^X-Content-Security: \[${HOST}\] REPORT: " | sed -e 's/^.* REPORT:/REPORT:/g'` }


    #---------------------------------------------------------------------------
    # Smart Sender Notify Suppression
    # If the Return-Path: domain is not supported by any of the Received: domains
    # then the envelope sender address is probably forged. Don't waste time notifying.
    #

    :0
    *   SECURITY_NOTIFY_SENDER ?? [^ ]
    *   FROMDOM ?? [^ ]
    * ! SECURITY_DISABLE_SMART_REPLY ?? [^ ]
    {
      FROMDOM2="_"
      FROMDOM3="_"

      :0
      * FROMDOM ?? ^.+\.\/[^.]+\.[^.]+$
      {
        FROMDOM2="$MATCH"
        # ignore some domains (e.g. ac.uk, com.ar, etc.)
        :0
        * FROMDOM2 ?? ^(co|ac|com|net|org)\.[a-z][a-z]$
        {
          FROMDOM2="_"
        }
      }

      :0
      * FROMDOM ?? ^.+\.\/[^.]+\.[^.]+\.[^.]+$
      {
        FROMDOM3="$MATCH"
      }

      :0 H
      * $! ^Received: from ([^ .]+\.)*($FROMDOM|$FROMDOM3|$FROMDOM2) \(
      * $! ^Received: from [^ ]+ \(([^ .]+\.)*($FROMDOM|$FROMDOM3|$FROMDOM2)[ ]
      {
        REPLY_SUPPRESSED="NOTICE: Envelope sender domain $FROMDOM not supported by Received: path. Suppressing sender notification.${NL}"
        LOG=" $REPLY_SUPPRESSED"
        SECURITY_NOTIFY_SENDER=
      }

      # Did a mailing list rewrite the Return-Path header?
      :0E
      * -1^0
      * 1^0 ^Precedence: (bulk|junk|list)
      * 1^0 ^(List-Id|X-Mailing-List):
      * 9876543210^0 FROM ?? \<owner-
      * 9876543210^0 FROM ?? \<[^@ >]+-l-admin@
      {
        REPLY_SUPPRESSED="NOTICE: Message from mailing list. Suppressing sender notification.${NL}"
        LOG=" $REPLY_SUPPRESSED"
        SECURITY_NOTIFY_SENDER=
      }
    }
    #---------------------------------------------------------------------------

    :0 HB
    * !$ ^X-Content-Security: \[${HOST}\] NONOTIFY
    {
       :0
       * SECURITY_NOTIFY ?? [^ ]
       * !$ ^X-Loop: EMAIL SECURITY WARNING $HOST $SECRET
       {
         LOG="${NL} NOTIFY ADMIN ($SECURITY_NOTIFY)${NL}"

         :0 h ci
         | ( \
             echo "To: $SECURITY_NOTIFY";\
             echo 'From: "Procmail Security daemon"' "<${SECURITY_LOCAL_POSTMASTER}>";\
             echo 'Subject: SECURITY WARNING - possible email attack';\
             echo "X-Loop: EMAIL SECURITY WARNING $HOST $SECRET"; \
             echo ;\
             echo "\$Revision: 1.138 $";\
             echo ;\
             echo "$REPORT";\
             echo "$SCORE";\
             echo "$STATUS";\
             echo "$REPLY_SUPPRESSED";\
             echo ;\
             echo 'Headers from message:';\
             echo ;\
             sed -e 's/^/> /' ;\
           ) | $SENDMAIL $MTA_FLAGS_CMDLN $SECURITY_NOTIFY
       }

       :0
       * SECURITY_NOTIFY_VERBOSE ?? [^ ]
       * !$ ^X-Loop: EMAIL SECURITY WARNING $HOST $SECRET
       {
         LOG="${NL} NOTIFY ADMIN VERBOSE ($SECURITY_NOTIFY_VERBOSE)${NL}"

         :0 hb ci
         | ( \
             echo "To: $SECURITY_NOTIFY_VERBOSE";\
             echo 'From: "Procmail Security daemon"' "<${SECURITY_LOCAL_POSTMASTER}>";\
             echo 'Subject: SECURITY WARNING - possible email attack';\
             echo "X-Loop: EMAIL SECURITY WARNING $HOST $SECRET"; \
             echo ;\
             echo "$REPORT";\
             echo "$SCORE";\
             echo "$STATUS";\
             echo "$REPLY_SUPPRESSED";\
             echo ;\
             echo 'Message:';\
             echo ;\
             sed -e 's/^/> /' ;\
           ) | $SENDMAIL $MTA_FLAGS_CMDLN $SECURITY_NOTIFY_VERBOSE
       }
    }

    :0 H
    * SECURITY_NOTIFY_SENDER ?? [^ ]
    * !  ^FROM_DAEMON
    * !$ ^X-Loop: EMAIL SECURITY WARNING $HOST $SECRET
    {
      LOG="${NL} NOTIFY SENDER${NL}"
      PM_BCC="X-Placeholder:"
      PM_CC="X-Placeholder:"

      :0 HB
      * !$ ^X-Content-Security: \[${HOST}\] NONOTIFY
      {
          PM_BCC="Bcc: $SECURITY_NOTIFY"
      }

      :0
      * SECURITY_NOTIFY_SENDER_POSTMASTER ?? [^ ]
      * FROMDOM ?? [^ ]
      {
          PM_CC="postmaster@$FROMDOM"

          :0
          * SECURITY_NOTIFY_SENDER_ABUSE ?? [^ ]
          {
            PM_CC="$PM_CC>, <abuse@$FROMDOM"
          }

          PM_CC="Cc: <$PM_CC>"
      }

      MSG_HEADERS=`sed -e '/^$/q; s/^/> /'`

      :0 h ci
      | ( \
          formail -r \
                  -I "From: \"Procmail Security daemon\" <${SECURITY_LOCAL_POSTMASTER}>"\
                  -I "$PM_BCC" -I "$PM_CC" -I "References: $MSGID" \
                  -I "Sender: <${SECURITY_LOCAL_POSTMASTER}>" \
                  -I "Errors-To: <${SECURITY_LOCAL_POSTMASTER}>" \
                  -I "X-Loop: EMAIL SECURITY WARNING $HOST $SECRET" \
                  -I "$OVERRIDEFORMAIL" \
          ;\
          echo ;\
          if [ -f "$SECURITY_NOTIFY_SENDER" -a -s "$SECURITY_NOTIFY_SENDER" -a -r "$SECURITY_NOTIFY_SENDER" ] ;\
          then \
                echo 'Regarding your message to';\
                echo "$TO";\
                echo ;\
                cat $SECURITY_NOTIFY_SENDER; \
          else \
                echo '*** SECURITY WARNING ***';\
                echo 'Our email gateway has detected that your message to';\
                echo "$TO";\
                echo 'MAY contain hazardous embedded scripting or attachments,';\
                echo 'or has been rejected by our site security policy for some other reason.';\
                echo 'If you have a question, please reply to this notification message.';\
                echo ;\
                echo 'It is POSSIBLE that your message was infected by a virus.';\
                echo 'You should make sure your virus signature file';\
                echo 'is up-to-date and then rescan your computer,';\
                echo 'especially if you do not remember sending this message.';\
                echo ;\
                echo 'If the macro scanner score is large yet your virus scanner reports';\
                echo 'that the document is not infected, try saving it using a different';\
                echo 'format (such as Rich Text - "RTF") that will remove all macros.';\
          fi ;\
          echo ;\
          echo "$REPORT";\
          echo "$SCORE";\
          echo "$STATUS_PUBLIC";\
          echo ;\
          echo 'Headers from message:';\
          echo ;\
          echo "$MSG_HEADERS";\
          echo ;\
          echo ;\
          echo '--';\
          echo 'Message sanitized on' $HOST;\
          echo 'See http://www.impsec.org/email-tools/sanitizer-intro.html for details.';\
          echo ;\
        ) | $SENDMAIL $MTA_FLAGS_HDRS

    }
  }

  :0
  * SECURITY_QUARANTINE ?? [^ ]
  {
    :0
    * SECURITY_NOTIFY_RECIPIENT ?? [^ ]
    {
      LOG="${NL} NOTIFY RECIPIENT${NL}"

      # We could stuff this directly into $DEFAULT but then
      # we'd have to worry about generating Message-ID and Date headers...
      :0 h ci
      | ( \
          echo "To: <$LOGNAME>";\
          echo 'From: "Procmail Security daemon"' "<${SECURITY_LOCAL_POSTMASTER}>";\
          echo 'Subject: SECURITY WARNING - email quarantined';\
          echo ;\
          if [ -f "$SECURITY_NOTIFY_RECIPIENT" -a -s "$SECURITY_NOTIFY_RECIPIENT" -a -r "$SECURITY_NOTIFY_RECIPIENT" ] ;\
          then \
                cat $SECURITY_NOTIFY_RECIPIENT; \
          else \
                echo '*** SECURITY WARNING ***';\
                echo 'Our email gateway has detected that a message sent to you';\
                echo 'MAY contain hazardous embedded scripting or attachments.';\
                echo 'The message has been quarantined or discarded per our site security policy.';\
                echo 'Please contact your system administrator for further details.';\
                echo ;\
          fi ;\
          echo ;\
          echo "$REPORT";\
          echo "$SCORE";\
          echo "$STATUS_PUBLIC";\
          echo ;\
          echo 'Headers from message:';\
          echo ;\
          sed -e 's/^/> /' ;\
          echo ;\
          echo '--';\
          echo 'Message sanitized on' $HOST;\
          echo 'See http://www.impsec.org/email-tools/sanitizer-intro.html for details.';\
          echo ;\
        ) | $SENDMAIL $MTA_FLAGS_HDRS

    }

    :0 :${SECURITY_QUARANTINE_LOCKFILE}
    $SECURITY_QUARANTINE

    :0 e
    * ! SECURITY_QUARANTINE_OPTIONAL ?? [^ ]
    {
      # Argh! Quarantine failed, and not explicitly marked as optional!
      # Bounce message, and notify administrator
      LOG="${NL} ERR: QUARANTINE FAILED!${NL}"
      EXITCODE=65

      :0 h
      * SECURITY_NOTIFY ?? [^ ]
      * !$ ^X-Loop: EMAIL SECURITY WARNING $HOST $SECRET
      | ( \
          echo "To: $SECURITY_NOTIFY";\
          echo 'From: "Procmail Security daemon"' "<${SECURITY_LOCAL_POSTMASTER}>";\
          echo 'Subject: SECURITY WARNING - quarantine failed!';\
          echo "X-Loop: EMAIL SECURITY WARNING $HOST $SECRET"; \
          echo ;\
          echo 'Attempt to quarantine the following message in $SECURITY_QUARANTINE failed.';\
          echo 'Message has been bounced.';\
          echo 'Verify file access permissions (file must be writable):';\
          ls -l $SECURITY_QUARANTINE ;\
          echo ;\
          echo "$REPORT";\
          echo "$SCORE";\
          echo ;\
          echo 'Headers from message:';\
          echo ;\
          sed -e 's/^/> /' ;\
        ) | $SENDMAIL $MTA_FLAGS_CMDLN $SECURITY_NOTIFY

      # zap it, just in case
      :0
      /dev/null
    }
  }
}

#eof